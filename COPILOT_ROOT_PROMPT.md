### Subject: Техническое Задание (Бриф) для SaaS LMS-Платформы на Django

**Проект:** Мы создаем с нуля **SaaS-платформу (LMS) для преподавателей** на Django. Это коммерческий B2B/B2C-продукт, где преподаватели являются нашими клиентами.

**Ключевая Концепция:** Платформа должна предоставить преподавателю полный набор инструментов "в одной коробке" для управления учебным процессом: от создания расписания до проведения уроков, проверки ДЗ и аналитики.

**Главная Техническая "Фича":** Мы **не** покупаем лицензию Zoom/Google Meet для каждого преподавателя. Мы реализуем **"Пул Ресурсов"** — ограниченное количество платных аккаунтов, которые система динамически выделяет преподавателям только на время урока и немедленно забирает обратно после.

---

### Архитектура и Основные Модули

* **Стек:** Django, Django REST Framework, Celery, PostgreSQL.
* **Фронтенд:** (Предположительно) React/Vue.js. Django будет предоставлять JSON API.
* **Ключевые Приложения Django:** `users`, `schedule`, `homework`, `analytics`.

---

### 1. Модуль `users`: Пользователи и Аутентификация

1.  **Кастомная Модель `User` (`AbstractUser`):**
    * **Вход:** Только по `email` (email = `USERNAME_FIELD`).
    * **Роли:** Обязательное поле `role` с `choices=('teacher', 'student')`.
2.  **Логика Входа (Критически Важно):**
    * **Шаг 0 (Выбор Роли):** Перед входом/регистрацией пользователь *обязан* выбрать, кто он: "Я Преподаватель" или "Я Ученик" . Эта роль (`role`) сохраняется в сессию.
    * **Шаг 1 (Вход):** Пользователь попадает на единый экран входа/регистрации (похожий на ).
    * **Логика:**
        * **Если `User.objects.filter(email=...).exists()`:** Произвести аутентификацию (логин).
        * **Если `User.objects.filter(email=...).exists() == False`:** Немедленно создать нового пользователя (`User.objects.create_user`) с этим `email`, `password` и **`role` из сессии**.
    * **OAuth:** Поддержать вход через соцсети (VK, Yandex) .

---

### 2. Модуль `schedule`: Группы и Расписание

1.  **Модель `Group` (Группа):**
    * `teacher` (ForeignKey к `User`).
    * `students` (ManyToManyField к `User`).
    * Преподаватель может создавать/редактировать группы и добавлять/удалять из них учеников .
2.  **Модель `Lesson` (Разовый Урок):**
    * `group` (ForeignKey), `teacher` (ForeignKey).
    * `start_time`, `end_time` (DateTimeField).
3.  **Модель `RecurringLesson` (Шаблон Регулярных Уроков):**
    * Это *правило*, а не конкретный урок.
    * Поля: `day_of_week` (0-6), `week_type` ('ALL', 'UPPER', 'LOWER' — для верхних/нижних недель), `start_time`, `end_time` (TimeField), `start_date`, `end_date` (DateField — "выполнять до...").
4.  **UI Календаря (FullCalendar.js):**
    * **Преподаватель:** Видит свой календарь . Он может создавать `Lesson` и `RecurringLesson`. Календарь должен "разворачивать" `RecurringLesson` на лету, чтобы показать сетку.
    * **Ученик:** Видит *только свой* календарь в режиме "read-only".

---

### 3. Модуль `schedule`: Проведение Уроков (Логика "Zoom Pool")

Это ядро нашей экономии.

1.  **Модель `ZoomAccount` (Пул аккаунтов):**
    * Хранит API-ключи, `zoom_user_id` и т.д.
    * **`is_busy` (BooleanField, `db_index=True`)** — ключевое поле.
    * `current_lesson` (OneToOneField к `Lesson`) — для отслеживания, кто занял.
2.  **Процесс "Начать Урок" (View):**
    * Преподаватель нажимает "Начать Урок" в календаре.
    * **Бэкенд (`start_lesson_view`):**
        1.  Начинает **атомарную транзакцию** (`transaction.atomic`).
        2.  Выполняет `ZoomAccount.objects.select_for_update().filter(is_busy=False).first()`.
        3.  **Если `None`:** (Все аккаунты заняты) -> Вернуть ошибку 429 "Попробуйте позже".
        4.  **Если аккаунт найден:** Мгновенно `account.is_busy = True`, `account.current_lesson = lesson`, `account.save()`. Транзакция завершается.
        5.  **После транзакции:** (Аккаунт "наш") — спокойно идем в API Zoom с ключами этого `account`.
        6.  Создаем звонок.
        7.  Сохраняем `zoom_start_url` и `zoom_join_url` в `Lesson`.
        8.  Отдаем `zoom_start_url` преподавателю для редиректа.
3.  **Процесс "Освобождение Аккаунта":**
    * **Способ 1 (Идеальный): Zoom Webhook.** Настроить эндпоинт, который слушает событие `meeting.ended`. По `meeting_id` он находит `Lesson`, затем `ZoomAccount` и ставит `is_busy = False`.
    * **Способ 2 (Резервный): Celery Beat Task.** Фоновая задача (каждые 5 мин) ищет `Lesson`, которые *должны были* закончиться (end_time + 15 мин), и принудительно освобождает их `ZoomAccount`.
4.  **Модель `LessonRecording`:**
    * Хранит `url` на запись урока (которая выгружается в S3/Cloudflare).
    * `lesson` (ForeignKey).

---

### 4. Модуль `homework`: Конструктор Домашних Заданий

1.  **Модель `Homework`:** Привязывается к `teacher` и (опционально) к `lesson`.
2.  **Модель `Question`:**
    * `homework` (ForeignKey).
    * `question_type` (Choices: 'TEXT' (ручная проверка), 'SINGLE_CHOICE', 'MULTI_CHOICE').
3.  **Модель `Choice`:** Варианты ответов для `SINGLE_CHOICE` / `MULTI_CHOICE`.
4.  **Процесс Сдачи (Модели `StudentSubmission` и `Answer`):**
    * Ученик создает `StudentSubmission` (попытка).
    * `Answer` хранит его ответ на конкретный `Question`.
    * Система автоматически ставит `grade` (оценку) за `SINGLE/MULTI_CHOICE` и ждет `grade` от `teacher` для `TEXT`.

---

### 5. Модуль `analytics`: Статистика и Журнал

1.  **Модель `Attendance` (Посещаемость):**
    * `lesson` (ForeignKey), `student` (ForeignKey), `status` ('present', 'absent').
    * Заполняется преподавателем (кнопка "Отметить посещение") .
2.  **Модель `ControlPoint` (Точка Контроля):**
    * Контрольная работа, тест, эссе. Отличается от ДЗ, т.к. сильнее влияет на итоговую оценку.
3.  **UI "Журнал" (Gradebook):**
    * Сводная таблица для преподавателя: (Ученики) x (Уроки/ДЗ/Контрольные).
    * Показывает: Посещаемость, Оценки.
4.  **UI "Дашборды":**
    * Графики успеваемости (индивидуальные и средние по группе).
