# =============================================================================
# PostgreSQL Configuration for Stage C (16-32GB RAM server)
# Optimized for high concurrency with PgBouncer
# Consider: Managed DB (RDS/Cloud SQL) with read replicas
# =============================================================================

# CONNECTIONS
max_connections = 200                   # PgBouncer manages actual connections
superuser_reserved_connections = 5

# MEMORY (25% of 16GB = 4GB for shared_buffers)
shared_buffers = 4GB
effective_cache_size = 12GB             # ~75% of RAM
work_mem = 128MB                        # For complex analytical queries
maintenance_work_mem = 1GB
huge_pages = on                         # Enable on production

# WRITE AHEAD LOG
wal_buffers = 128MB
checkpoint_completion_target = 0.9
max_wal_size = 8GB
min_wal_size = 2GB

# QUERY PLANNER (NVMe SSD with high IOPS)
random_page_cost = 1.0
effective_io_concurrency = 300
default_statistics_target = 200

# PARALLELISM (8 vCPU)
max_parallel_workers_per_gather = 4
max_parallel_workers = 8
max_parallel_maintenance_workers = 4
parallel_tuple_cost = 0.01
parallel_setup_cost = 500

# LOGGING
log_min_duration_statement = 200        # Log queries > 200ms
log_checkpoints = on
log_lock_waits = on
log_temp_files = 0
log_autovacuum_min_duration = 200

# AUTOVACUUM (aggressive for high write volume)
autovacuum_max_workers = 4
autovacuum_naptime = 20s
autovacuum_vacuum_threshold = 20
autovacuum_analyze_threshold = 20
autovacuum_vacuum_cost_limit = 600

# STATEMENT TIMEOUT
statement_timeout = 30000
idle_in_transaction_session_timeout = 30000

# REPLICATION (for read replicas)
# wal_level = replica
# max_wal_senders = 5
# max_replication_slots = 5
